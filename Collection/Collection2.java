                                                     collection

-unique objecte data is better comparitivaly...
-collection is not duplicate value
-hashset 

[set]
=is not store by index==
=and do not  duplicate value==output;






LinkedHashSet--Order












[itaretar]

=itaretar is avalable in== *itarable

= gottilla ....aviod itaratar intefence

=itaretar way use ==(fecth data)

=not for loop use in this using the iterator method
 
=iterfece come from "java.util package"



java 8 feature 
=commaly use data ==this point is (imp)
=collecte data 

=hashNext() is (boolean) type ..data if avalable is true ..no there false
=hashNext is to next is ther u go next 

root class method 11 objecte are there



((ArrayList ))

==output same as leakedList.
==search laest Faster then leakedList
==sequance order save
==more no are use in this
==this is class and becouse faster compare to leakedList
==randem Access becouse faster compare to leakedList
==grow method cll: when more then index we written 
==capcity of index 10
==  if giving more then index swift operation ====10   (10>>1)
==(0,"sub")=if index incremental value only we written all in one side taken output not  exception
  { list.add(null);
   list.add(0,"subjecte");
  list.add(4,"subjecte");}==it kake out put indx 0, null,4

 LinkedList==
 
==search list not recomended
==
==Doubly Linked list=== previous and present value and next value
 ==node: are 3 basic information give 
==randem but index vise sequance order fecth becouse slow fecth the data
 
 

[TreeSet]


==TreeSet--Used For 
==upper" case 1st come output
==incremental 1st "number" come oput time
==TreeSet== internally use treeBlackValue	
==compare data


==output...incremental value come.
==Set set=new TreeSet

==make it all data string ither number == otpt come string or int
==salt the i want then (impliment)





HashSet vs TreeSet  ======imp

:::HashSet:::

--Not in order ==otpt come.
-it is class. 
-java util pakage.
-internaly use the (map)
--use to store the formate (key and value )or (e,PRESENT)
--map=new HashMap<>();
--map.put(E,value)==null;
--put=method
--take unique value
--set has map realtion
==homogenus data only



ArrayList compare 







DTO>properties

marker interface if any empty construter is there this purpose we(sertializeable) last layer s
not all class transper when transper that case or objecte genraly make it seriaizale
just more protection..And one cls to anther class or layer 


((DTO))
data transper object ===transper one class to anther class

enum== used as canstant value EX ...gender==male,female,transgender

addSale


comparator---compare(2 parameter) lang
comparable---compare(1 parameter) util

DTO(data tranmsfer object...one layer to anther layer) to do ==designec or to add data

functiona intefence==1 

intefence==one or more  abstracte method

@functonalInterface


<<<<java 8 features>>>>

functiona intefence==1
Stream API
Date API
Lambda exprerences
method refencess
Static method and defaulte method 
optional
neshron

==it reduce the or compacte (code) 
==to intruduse the [[[[fuctional program]]]




							<<<<<	lambda()->    >>>>>  
anonomous fuction (anonomes gives the out put)== ? lambda	
no use in acces modifeyr,no return type
						
lambda exception==interface in give out put purpose
 
 Addition add=(num1,num2)->sop(num+num2);
 
 lambda fuctional==  ->sop(num1+num2);
 lambda  ==  ->
 
 
 
 List<intiger> list =new ArrayList<Intiger>
 
 list.add(13);
 
 Iterator<> itr........
 --------------------------------------------------------------------------------------------
 <<<stream>>>>
 
 condition time==used filter
 
 
 list.stream().forEach(intigerValue->SOP(intigerValue));
 
 List<intiger> listofEvenNumbers=list.stream().flter(inValue % 2 !==0).collectors.toList());
 sop (listofEvenNumbers);
 
 
 
 
 
 
 
 
 
 
 

interface class
abstract void add(String a , int b);


main method 
Addition add=(num1,num2)->sop(num1+num2);

add.add(12,78)


BufferedRead scan =new 

readline

---------------------------------
L<Intiger > list =new AL<Intiger>
lisi.add(234);

Consumer<Intiger> intrVal=ref->sop(ref);
intrVal.accept()null;


list.stream()




list.stream().filter(ref->(ref % 2 !=0).forEach (intValue->sop()

l//ist.stream().filter(ref->(ref % 2 !=0).forEach (intValue->sop()

BiConsumer<Intiger,Intiger>ref= (num1,num2)->sop (num);
list.stream().forEach(ref->sop(ref));

class ..chair

pub int putoSit(){
int i= 89*78


impliment->.  leftside condition->

defalte satatic
 
 [[[fuctional interface]]]] 
 1consumer--accept()........it give the data and get it purpose
 2fuction--affly(T t);
 3predicate--test(T t)---boolean
 4supplair--   get class .........test(T t)



list.stream.collector(collectors.toList());


--------------------------------------------------------

static refece we can use defaulte

default not======== overriding
static===con not override


interface

void  static (String a,int b)
publc static int addWith somthing(int, int ,int)


default not======== overriding
static===con not override

impliment

overrid

c=c*100;
retun a+b+c;


main

Addition add=new additionIMPL();
add.addwithsomething(67,7,60);
sop(total);





main

int total =Addition.addwithsomething(67,7,60);
sop(totl);

--------------------------------------------------------------------

::    method reference

List<>
list.add(12);
sop(list.stream().max(Comparator.comparing(Integer::intValue)));

sop(list.stream().mapToInt(Integer::intValue).max())  

{or}
sop(list.stream().min(Comparator.comparing(Integer::intValue));
                                           (managerDTO::getValue)==max salery are added inlist

list.stream.collect(collectors.maxBy(Comparator.naturalOrder()))
collect or forEach

---------------------------------------------------
emplyee.stream().sorted(emp1,emp2 ->emp1.getSalary()).forEach(s1->sop(s1))

emplyee.stream().filter(emp->emp.getSalary()>3000000.collect(null);


----------------------------
JSE---java standerd edition

JME--java mobaile edition --micro edition

JEE--java enterprise edition--it is hevy...it have more class have compare jse
==it can any body access anywhere
==enternet application we requred



{{Spring}}
==it is appliction develoment framework

==it is used to manage objectes like used define ,inbuilt objecte

==it is an implimentaion of IOC(IOC is a very imp ==IOC means Inversion of Control) and DI (Defendency Injection) 


























